<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>å…±è¯†æœºåˆ¶ - Agave Validator Documentation</title>
    <link rel="stylesheet" href="style.css">
    <link rel="icon" href="data:image/svg+xml,<svg xmlns=%22http://www.w3.org/2000/svg%22 viewBox=%220 0 100 100%22><text y=%22.9em%22 font-size=%2290%22>ğŸŒªï¸</text></svg>">
</head>
<body>
    <div class="container">
        <!-- Search Bar -->
        <div class="search-container">
            <input type="text" class="search-bar" placeholder="æœç´¢æ–‡æ¡£..." id="searchInput">
            <a href="index.html" class="back-link">â† è¿”å›é¦–é¡µ</a>
        </div>

        <!-- Header -->
        <header class="header">
            <h1>ğŸ”— å…±è¯†æœºåˆ¶</h1>
            <p class="subtitle">æ·±å…¥ç†è§£Solanaçš„å…±è¯†ç®—æ³•ä¸å®ç°</p>
        </header>

        <!-- Overview -->
        <div class="content">
            <h2>ğŸ“Š å…±è¯†æœºåˆ¶æ¦‚è¿°</h2>
            <div class="alert alert-info">
                <strong>æ ¸å¿ƒè¦ç‚¹ï¼š</strong> Solanaé‡‡ç”¨Proof of History (PoH) + Tower BFTçš„æ··åˆå…±è¯†æœºåˆ¶ï¼Œç»“åˆäº†æ—¶é—´æˆ³è¯æ˜å’Œæ‹œå åº­å®¹é”™ç®—æ³•çš„ä¼˜åŠ¿ã€‚
            </div>
            
            <div class="architecture-grid">
                <div class="component-card">
                    <h3>Proof of History</h3>
                    <ul>
                        <li>å¯éªŒè¯å»¶è¿Ÿå‡½æ•°</li>
                        <li>å…¨å±€æ—¶é—´æˆ³è¯æ˜</li>
                        <li>é¡ºåºæ€§ä¿è¯</li>
                        <li>é«˜æ•ˆéªŒè¯</li>
                    </ul>
                </div>

                <div class="component-card">
                    <h3>Tower BFT</h3>
                    <ul>
                        <li>æŠ•ç¥¨é”å®šæœºåˆ¶</li>
                        <li>åˆ†å‰é€‰æ‹©è§„åˆ™</li>
                        <li>ç»æµæƒ©ç½šæœºåˆ¶</li>
                        <li>å…±è¯†æ”¶æ•›ä¿è¯</li>
                    </ul>
                </div>

                <div class="component-card">
                    <h3>é¢†å¯¼è€…è°ƒåº¦</h3>
                    <ul>
                        <li>åŸºäºæƒç›Šçš„é€‰æ‹©</li>
                        <li>éšæœºæ€§ä¿è¯</li>
                        <li>å…¬å¹³æ€§æœºåˆ¶</li>
                        <li>é˜²ä½œæ¶è®¾è®¡</li>
                    </ul>
                </div>

                <div class="component-card">
                    <h3>æŠ•ç¥¨æœºåˆ¶</h3>
                    <ul>
                        <li>æƒç›ŠåŠ æƒæŠ•ç¥¨</li>
                        <li>æŠ•ç¥¨ç¡®è®¤è§„åˆ™</li>
                        <li>åˆ†å‰å¤„ç†ç­–ç•¥</li>
                        <li>å¥–åŠ±åˆ†é…æœºåˆ¶</li>
                    </ul>
                </div>
            </div>
        </div>

        <!-- Proof of History -->
        <div class="content">
            <h2>âš¡ Proof of Historyæœºåˆ¶</h2>
            
            <div class="pipeline-section">
                <h3>1. å·¥ä½œåŸç†</h3>
                <pre><code>// æ–‡ä»¶: poh/src/poh_recorder.rs
use solana_sdk::hash::{Hash, Hasher};
use solana_sdk::timing::timestamp;

#[derive(Debug)]
pub struct PohRecorder {
    // PoHå“ˆå¸Œé“¾çŠ¶æ€
    pub hash: Hash,
    // tickè®¡æ•°å™¨
    pub tick_count: u64,
    // æœ€åä¸€æ¬¡tickçš„æ—¶é—´æˆ³
    pub timestamp: Option<UnixTimestamp>,
    // PoHç”Ÿæˆå™¨
    pub poh: Poh,
}

impl PohRecorder {
    pub fn tick(&mut self) {
        self.hash = hash(&self.hash.as_ref());
        self.tick_count += 1;
        self.timestamp = Some(timestamp());
    }
    
    pub fn record(&mut self, data: &[u8]) -> Option<Hash> {
        let mut hasher = Hasher::default();
        hasher.hash(&self.hash.as_ref());
        hasher.hash(data);
        self.hash = hasher.result();
        Some(self.hash)
    }
}</code></pre>
                <p>Proof of History (PoH) æ˜¯ä¸€ç§å¯éªŒè¯å»¶è¿Ÿå‡½æ•° (VDF)ï¼Œé€šè¿‡è¿ç»­çš„å“ˆå¸Œè¿ç®—åˆ›å»ºä¸€ä¸ªåŠ å¯†æ—¶é’Ÿï¼Œä¸ºåŒºå—é“¾æä¾›å…¨å±€æ—¶é—´å‚è€ƒã€‚ä¸»è¦ç‰¹ç‚¹ï¼š</p>
                <ul>
                    <li>è¿ç»­å“ˆå¸Œè¿ç®—ç”Ÿæˆæ—¶é—´è¯æ˜</li>
                    <li>æ¯ä¸ªå“ˆå¸Œéƒ½ä¾èµ–å‰ä¸€ä¸ªå“ˆå¸Œ</li>
                    <li>å¯ä»¥å¹¶è¡ŒéªŒè¯æ—¶é—´è¯æ˜</li>
                    <li>ä¸ºäº¤æ˜“æä¾›å…¨å±€é¡ºåº</li>
                </ul>
            </div>

            <div class="pipeline-section">
                <h3>2. æ—¶é—´æ§½è®¾è®¡</h3>
                <pre><code>// æ–‡ä»¶: sdk/src/timing.rs
pub const SLOT_DURATION_MS: u64 = 400; // æ¯«ç§’
pub const TICKS_PER_SLOT: u64 = 160; // æ¯ä¸ªæ§½çš„tickæ•°
pub const DEFAULT_TICK_DURATION_US: u64 = (SLOT_DURATION_MS * 1000) / TICKS_PER_SLOT;

// æ–‡ä»¶: runtime/src/bank.rs
impl Bank {
    pub fn new_from_parent(&self, parent: &Arc<Bank>, slot: Slot) -> Self {
        let mut bank = Bank {
            slot,
            tick_height: parent.tick_height + TICKS_PER_SLOT,
            // PoHå“ˆå¸Œç»§æ‰¿è‡ªçˆ¶åŒºå—
            poh_hash: parent.poh_hash,
            ..
        };
        
        // éªŒè¯æ—¶é—´æ§½çš„æœ‰æ•ˆæ€§
        assert!(bank.slot > parent.slot);
        bank
    }
}</code></pre>
                <ul>
                    <li>æ¯ä¸ªæ§½æŒç»­400æ¯«ç§’</li>
                    <li>æ§½å†…åŒ…å«å›ºå®šæ•°é‡çš„tick</li>
                    <li>é¢†å¯¼è€…åœ¨æ§½å†…ç”ŸæˆåŒºå—</li>
                    <li>ä¿è¯äº¤æ˜“å¤„ç†çš„æ—¶åºæ€§</li>
                </ul>
            </div>

            <div class="pipeline-section">
                <h3>3. å®‰å…¨æ€§ä¿è¯</h3>
                <div class="alert alert-warning">
                    <strong>æ³¨æ„ï¼š</strong> PoHçš„å®‰å…¨æ€§ä¾èµ–äºå“ˆå¸Œè¿ç®—çš„å•çº¿ç¨‹ç‰¹æ€§ï¼Œä»»ä½•å¹¶è¡Œä¼˜åŒ–éƒ½å¯èƒ½å½±å“å®‰å…¨æ€§ã€‚
                </div>
                <ul>
                    <li>å“ˆå¸Œé“¾ä¸å¯ä¼ªé€ </li>
                    <li>æ—¶é—´è¯æ˜å¯éªŒè¯</li>
                    <li>é˜²æ­¢æ—¶é—´æˆ³ç¯¡æ”¹</li>
                    <li>æŠµå¾¡é‡æ”¾æ”»å‡»</li>
                </ul>
            </div>
        </div>

        <!-- Tower BFT -->
        <div class="content">
            <h2>ğŸ—¼ Tower BFTå…±è¯†</h2>
            
            <div class="pipeline-section">
                <h3>1. æŠ•ç¥¨å¡”æœºåˆ¶</h3>
                <pre><code>// æ–‡ä»¶: core/src/consensus/tower.rs
use solana_sdk::clock::Slot;
use solana_sdk::hash::Hash;
use solana_vote_program::vote_state::Lockout;

#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct Tower {
    // å½“å‰æŠ•ç¥¨é«˜åº¦
    pub node_pubkey: Pubkey,
    // é˜ˆå€¼æ·±åº¦
    pub threshold_depth: usize,
    // é˜ˆå€¼å¤§å°
    pub threshold_size: f64,
    // æŠ•ç¥¨å†å²è®°å½•
    pub vote_state: VoteState,
    // æŠ•ç¥¨é”å®šæœŸ
    pub lockouts: VecDeque<Lockout>,
    // æœ€åæŠ•ç¥¨æ§½
    pub last_vote: Vote,
}

impl Tower {
    // æ£€æŸ¥æ˜¯å¦å¯ä»¥æŠ•ç¥¨ç»™æŒ‡å®šæ§½
    pub fn check_vote_stake_threshold(
        &self,
        slot: Slot,
        voted_stakes: &VotedStakes,
        total_stake: u64,
    ) -> ThresholdDecision {
        let stake_lockouts = self.collect_vote_lockouts(
            slot,
            voted_stakes.slot_stakes(),
        );
        
        // è®¡ç®—æ”¯æŒçš„æƒç›Š
        let threshold = (2f64 / 3f64) * total_stake as f64;
        if stake_lockouts > threshold {
            ThresholdDecision::PassedThreshold
        } else {
            ThresholdDecision::FailedThreshold(stake_lockouts, threshold)
        }
    }
}</code></pre>
                <p>Tower BFTé€šè¿‡æŠ•ç¥¨é”å®šæœºåˆ¶ç¡®ä¿å…±è¯†çš„å®‰å…¨æ€§å’Œæ´»æ€§ï¼š</p>
                <ul>
                    <li>æŠ•ç¥¨é€å±‚ç´¯ç§¯</li>
                    <li>é”å®šæœŸæŒ‡æ•°å¢é•¿</li>
                    <li>32ç¥¨è¾¾åˆ°æœ€å¤§é”å®š</li>
                    <li>è¿åé”å®šå°†è¢«æƒ©ç½š</li>
                </ul>
            </div>

            <div class="pipeline-section">
                <h3>2. åˆ†å‰é€‰æ‹©è§„åˆ™</h3>
                <pre><code>// æ–‡ä»¶: core/src/consensus/fork_choice.rs
use std::collections::HashMap;
use solana_ledger::blockstore::Blockstore;

#[derive(Debug)]
pub struct HeaviestSubtreeForkChoice {
    fork_tree: ForkTree,
    stake_voted_at: HashMap<u64, u64>,
    stake_voted_subtree: HashMap<u64, u64>,
}

impl HeaviestSubtreeForkChoice {
    // è®¡ç®—æœ€é‡å­æ ‘æƒé‡
    pub fn compute_bank_stats(
        &mut self,
        bank: &Bank,
        tower: &Tower,
        progress: &ProgressMap,
    ) -> BankWeight {
        let mut voted_stakes = HashMap::new();
        let total_stake = bank.total_epoch_stake();
        
        // éå†æ‰€æœ‰æŠ•ç¥¨è´¦æˆ·
        for (vote_pubkey, (stake, vote_account)) in bank.vote_accounts() {
            if let Some(vote_state) = VoteState::from(&vote_account) {
                for vote in &vote_state.votes {
                    let slot_stake = voted_stakes.entry(vote.slot).or_insert(0);
                    *slot_stake += stake;
                }
            }
        }
        
        // è®¡ç®—å½“å‰åˆ†å‰çš„æƒé‡
        let mut fork_weight = 0u64;
        for ancestor in bank.ancestors.keys() {
            if let Some(stake) = voted_stakes.get(ancestor) {
                fork_weight += stake;
            }
        }
        
        BankWeight { 
            fork_weight,
            fork_stake: voted_stakes,
            total_stake,
        }
    }
}</code></pre>
                <ul>
                    <li>é€‰æ‹©æœ€é‡åˆ†å‰</li>
                    <li>æƒç›ŠåŠ æƒè®¡ç®—</li>
                    <li>è€ƒè™‘é”å®šæœŸå½±å“</li>
                    <li>ä¿è¯åˆ†å‰æ”¶æ•›</li>
                </ul>
            </div>

            <div class="pipeline-section">
                <h3>3. ç¡®è®¤æœºåˆ¶</h3>
                <div class="alert alert-success">
                    <strong>ç¡®è®¤è§„åˆ™ï¼š</strong> åŒºå—éœ€è¦è·å¾—è¶…è¿‡2/3æƒç›Šçš„æŠ•ç¥¨æ‰èƒ½è¢«ç¡®è®¤ã€‚
                </div>
                <ul>
                    <li>ä¹è§‚ç¡®è®¤ï¼š2/3æƒç›ŠæŠ•ç¥¨</li>
                    <li>æœ€ç»ˆç¡®è®¤ï¼š32ä¸ªè¿ç»­æŠ•ç¥¨</li>
                    <li>é˜²æ­¢åŒèŠ±æ”»å‡»</li>
                    <li>ä¿è¯äº¤æ˜“ç»ˆå±€æ€§</li>
                </ul>
            </div>
        </div>

        <!-- Leader Schedule -->
        <div class="content">
            <h2>ğŸ‘‘ é¢†å¯¼è€…è°ƒåº¦</h2>
            
            <div class="pipeline-section">
                <h3>1. è°ƒåº¦ç®—æ³•</h3>
                <pre><code>// æ–‡ä»¶: runtime/src/leader_schedule.rs
use rand::{Rng, SeedableRng};
use rand_chacha::ChaChaRng;
use solana_sdk::pubkey::Pubkey;

pub const NUM_CONSECUTIVE_LEADER_SLOTS: usize = 4;

impl LeaderSchedule {
    pub fn new(
        vote_accounts: &VoteAccounts,
        epoch_schedule: &EpochSchedule,
        epoch: Epoch,
    ) -> Self {
        let stakes: Vec<(Pubkey, u64)> = vote_accounts
            .iter()
            .map(|(pubkey, (stake, _))| (*pubkey, *stake))
            .collect();
            
        // ä½¿ç”¨epochä½œä¸ºéšæœºç§å­
        let mut seed = [0u8; 32];
        seed[0..8].copy_from_slice(&epoch.to_le_bytes());
        let mut rng = ChaChaRng::from_seed(seed);
        
        let total_stake: u64 = stakes.iter().map(|(_, stake)| *stake).sum();
        let slots_in_epoch = epoch_schedule.get_slots_in_epoch(epoch);
        
        let mut schedule = Vec::with_capacity(slots_in_epoch as usize);
        
        // ä¸ºæ¯ä¸ªæ§½åˆ†é…é¢†å¯¼è€…
        for slot_index in 0..slots_in_epoch {
            let mut cumulative_stake = 0u64;
            let target = rng.gen_range(0..total_stake);
            
            for (pubkey, stake) in &stakes {
                cumulative_stake += stake;
                if cumulative_stake > target {
                    schedule.push(*pubkey);
                    break;
                }
            }
        }
        
        LeaderSchedule::new_from_schedule(schedule)
    }
}</code></pre>
                <ul>
                    <li>æ¯ä¸ªepoché‡æ–°è®¡ç®—</li>
                    <li>åŸºäºæƒç›ŠåŠ æƒéšæœº</li>
                    <li>æå‰ä¸€ä¸ªepochç¡®å®š</li>
                    <li>ä¿è¯å…¬å¹³æ€§</li>
                </ul>
            </div>

            <div class="pipeline-section">
                <h3>2. æ—¶é—´æ§½åˆ†é…</h3>
                <pre><code>// æ–‡ä»¶: sdk/src/epoch_schedule.rs
#[derive(Debug, Clone, Copy, PartialEq, Eq)]
pub struct EpochSchedule {
    /// æ¯ä¸ªepochçš„æ§½æ•°
    pub slots_per_epoch: u64,
    /// é¢†å¯¼è€…è°ƒåº¦è®¡ç®—çš„åç§»é‡  
    pub leader_schedule_slot_offset: u64,
    /// æ˜¯å¦å¯ç”¨é¢„çƒ­æœŸ
    pub warmup: bool,
    /// ç¬¬ä¸€ä¸ªæ­£å¸¸é•¿åº¦çš„epoch
    pub first_normal_epoch: Epoch,
    /// ç¬¬ä¸€ä¸ªæ­£å¸¸æ§½
    pub first_normal_slot: Slot,
}

impl EpochSchedule {
    pub fn new(slots_per_epoch: u64) -> Self {
        Self {
            slots_per_epoch,
            leader_schedule_slot_offset: slots_per_epoch,
            warmup: true,
            first_normal_epoch: 0,
            first_normal_slot: 0,
        }
    }
    
    /// è·å–æŒ‡å®šæ§½çš„epochä¿¡æ¯
    pub fn get_epoch_and_slot_index(&self, slot: Slot) -> (Epoch, SlotIndex) {
        if slot < self.first_normal_slot {
            // é¢„çƒ­æœŸè®¡ç®—
            let epoch = (slot + MINIMUM_SLOTS_PER_EPOCH + 1)
                .next_power_of_two()
                .trailing_zeros() - MINIMUM_SLOTS_PER_EPOCH.trailing_zeros() - 1;
            let epoch_len = 2_u64.pow(epoch) * MINIMUM_SLOTS_PER_EPOCH;
            let slot_index = slot - (epoch_len - MINIMUM_SLOTS_PER_EPOCH);
            (epoch as u64, slot_index)
        } else {
            // æ­£å¸¸æœŸè®¡ç®—
            let normal_slot_index = slot - self.first_normal_slot;
            let normal_epoch_index = normal_slot_index / self.slots_per_epoch;
            let epoch = self.first_normal_epoch + normal_epoch_index;
            let slot_index = normal_slot_index % self.slots_per_epoch;
            (epoch, slot_index)
        }
    }
}</code></pre>
                <ul>
                    <li>æ¯ä¸ªé¢†å¯¼è€…4ä¸ªè¿ç»­æ§½</li>
                    <li>æ§½ä½å›ºå®šæ—¶é•¿400ms</li>
                    <li>é”™è¿‡æ§½ä½è‡ªåŠ¨è·³è¿‡</li>
                    <li>é˜²æ­¢å•ç‚¹æ•…éšœ</li>
                </ul>
            </div>

            <div class="pipeline-section">
                <h3>3. å®‰å…¨ä¿éšœ</h3>
                <div class="alert alert-info">
                    <strong>è®¾è®¡åŸåˆ™ï¼š</strong> é€šè¿‡éšæœºæ€§å’Œæƒç›Šçº¦æŸç¡®ä¿é¢†å¯¼è€…è¡Œä¸ºçš„å…¬å¹³æ€§å’Œå®‰å…¨æ€§ã€‚
                </div>
                <ul>
                    <li>é˜²æ­¢é¢„æµ‹æ€§æ”»å‡»</li>
                    <li>æƒç›Šæƒ©ç½šæœºåˆ¶</li>
                    <li>å¿«é€Ÿæ•…éšœæ¢å¤</li>
                    <li>åˆ†å¸ƒå¼å®¹é”™</li>
                </ul>
            </div>
        </div>

        <!-- Voting Mechanism -->
        <div class="content">
            <h2>ğŸ—³ï¸ æŠ•ç¥¨æœºåˆ¶</h2>
            
            <div class="pipeline-section">
                <h3>1. æŠ•ç¥¨æµç¨‹</h3>
                <pre><code>// æ–‡ä»¶: programs/vote/src/vote_state.rs
use solana_sdk::clock::Slot;
use solana_sdk::hash::Hash;
use solana_sdk::pubkey::Pubkey;

#[derive(Debug, Clone, PartialEq, Eq, Serialize, Deserialize)]
pub struct VoteState {
    /// æŠ•ç¥¨è´¦æˆ·çš„æˆæƒè€…
    pub authorized_voter: Pubkey,
    /// æŠ•ç¥¨å†å²è®°å½•
    pub votes: VecDeque<Lockout>,
    /// æ ¹æ§½ - å·²æœ€ç»ˆç¡®è®¤çš„æ§½
    pub root_slot: Option<Slot>,
    /// æœ€åæ—¶é—´æˆ³
    pub last_timestamp: BlockTimestamp,
    /// epochç§¯åˆ†
    pub epoch_credits: Vec<(Epoch, u64, u64)>,
}

#[derive(Debug, Clone, PartialEq, Eq, Serialize, Deserialize)]
pub struct Lockout {
    /// æŠ•ç¥¨çš„æ§½
    pub slot: Slot,
    /// ç¡®è®¤è®¡æ•°ï¼ˆæŒ‡æ•°å¢é•¿ï¼‰
    pub confirmation_count: u32,
}

impl Lockout {
    pub fn new(slot: Slot) -> Self {
        Self {
            slot,
            confirmation_count: 1,
        }
    }
    
    /// è®¡ç®—é”å®šæœŸï¼ˆ2^confirmation_countï¼‰
    pub fn lockout(&self) -> u64 {
        2_u64.pow(self.confirmation_count)
    }
    
    /// è®¡ç®—è¿‡æœŸæ§½
    pub fn expiration_slot(&self) -> Slot {
        self.slot + self.lockout()
    }
}</code></pre>
                <ul>
                    <li>éªŒè¯åŒºå—æœ‰æ•ˆæ€§</li>
                    <li>ç”ŸæˆæŠ•ç¥¨äº¤æ˜“</li>
                    <li>å¹¿æ’­åˆ°ç½‘ç»œ</li>
                    <li>ç­‰å¾…ç¡®è®¤</li>
                </ul>
            </div>

            <div class="pipeline-section">
                <h3>2. æŠ•ç¥¨ç¡®è®¤</h3>
                <pre><code>// æ–‡ä»¶: sdk/src/commitment_config.rs
#[derive(Debug, Clone, Copy, Eq, Hash, PartialEq, Serialize, Deserialize)]
#[serde(rename_all = "camelCase")]
pub enum CommitmentLevel {
    /// å·²å¤„ç†ä½†å¯èƒ½è¢«å›æ»š
    Processed,
    /// è·å¾—å¤šæ•°ç¡®è®¤ï¼Œå¾ˆå¯èƒ½æœ€ç»ˆç¡®è®¤
    Confirmed,
    /// ç»è¿‡32ä¸ªç¡®è®¤ï¼Œè¾¾åˆ°æœ€å¤§é”å®šæœŸ
    Finalized,
}

// æ–‡ä»¶: rpc/src/rpc_subscriptions.rs
impl RpcSubscriptions {
    /// æ£€æŸ¥æ§½çš„ç¡®è®¤çŠ¶æ€
    pub fn check_commitment_and_notify(
        &self,
        slot: Slot,
        bank: &Bank,
        commitment: CommitmentSlots,
    ) {
        // å¤„ç†å·²è¢«å¤„ç†çš„æ§½
        if commitment.slot <= slot {
            self.notify_subscribers(slot, &bank, CommitmentLevel::Processed);
        }
        
        // æ£€æŸ¥ç¡®è®¤çŠ¶æ€
        if let Some(confirmed_slot) = commitment.confirmed_slot {
            if confirmed_slot <= slot {
                self.notify_subscribers(slot, &bank, CommitmentLevel::Confirmed);
            }
        }
        
        // æ£€æŸ¥æœ€ç»ˆç¡®è®¤
        if let Some(finalized_slot) = commitment.finalized_slot {
            if finalized_slot <= slot {
                self.notify_subscribers(slot, &bank, CommitmentLevel::Finalized);
            }
        }
    }
}</code></pre>
                <ul>
                    <li>å¤„ç†ï¼šäº¤æ˜“å·²åŒ…å«åœ¨åŒºå—ä¸­</li>
                    <li>ç¡®è®¤ï¼šè·å¾—2/3æƒç›ŠæŠ•ç¥¨</li>
                    <li>æœ€ç»ˆç¡®è®¤ï¼š32ä¸ªè¿ç»­æŠ•ç¥¨</li>
                    <li>ä¸åŒç¡®è®¤çº§åˆ«æ»¡è¶³ä¸åŒå®‰å…¨éœ€æ±‚</li>
                </ul>
            </div>

            <div class="pipeline-section">
                <h3>3. å¥–åŠ±æœºåˆ¶</h3>
                <div class="alert alert-success">
                    <strong>æ¿€åŠ±æœºåˆ¶ï¼š</strong> é€šè¿‡é€šèƒ€å¥–åŠ±å’Œäº¤æ˜“è´¹ç”¨æ¿€åŠ±éªŒè¯è€…å‚ä¸å…±è¯†ã€‚
                </div>
                <ul>
                    <li>åŒºå—å¥–åŠ±</li>
                    <li>æŠ•ç¥¨å¥–åŠ±</li>
                    <li>äº¤æ˜“è´¹åˆ†æˆ</li>
                    <li>æƒ©ç½šæœºåˆ¶</li>
                </ul>
            </div>
        </div>

        <!-- Security Considerations -->
        <div class="content">
            <h2>ğŸ”’ å®‰å…¨æ€§è€ƒè™‘</h2>
            
            <div class="optimization-section">
                <h3>1. æ‹œå åº­å®¹é”™</h3>
                <div class="alert alert-info">
                    <strong>å®¹é”™èƒ½åŠ›ï¼š</strong> ç³»ç»Ÿå¯ä»¥å®¹å¿ä¸è¶…è¿‡1/3çš„æ¶æ„èŠ‚ç‚¹ã€‚
                </div>
                <ul>
                    <li>è¶…è¿‡2/3èŠ‚ç‚¹è¯šå®</li>
                    <li>å°‘äº1/3èŠ‚ç‚¹ä½œæ¶</li>
                    <li>å®‰å…¨é˜ˆå€¼ä¿è¯</li>
                    <li>å¿«é€Ÿæ•…éšœæ¢å¤</li>
                </ul>
            </div>

            <div class="optimization-section">
                <h3>2. æ”»å‡»é˜²æŠ¤</h3>
                <div class="alert alert-warning">
                    <strong>é˜²æŠ¤æœºåˆ¶ï¼š</strong> å¤šå±‚æ¬¡çš„å®‰å…¨é˜²æŠ¤ç¡®ä¿ç³»ç»Ÿç¨³å®šæ€§ã€‚
                </div>
                <ul>
                    <li>åŒèŠ±æ”»å‡»é˜²æŠ¤</li>
                    <li>é•¿ç¨‹æ”»å‡»é˜²æŠ¤</li>
                    <li>å¥³å·«æ”»å‡»é˜²æŠ¤</li>
                    <li>DDoSæ”»å‡»é˜²æŠ¤</li>
                </ul>
            </div>

            <div class="optimization-section">
                <h3>3. ç»æµå®‰å…¨</h3>
                <div class="alert alert-success">
                    <strong>æ¿€åŠ±ç›¸å®¹ï¼š</strong> ç»æµæ¿€åŠ±æœºåˆ¶ç¡®ä¿å‚ä¸è€…éµå®ˆåè®®è§„åˆ™ã€‚
                </div>
                <ul>
                    <li>æƒç›ŠæŠµæŠ¼è¦æ±‚</li>
                    <li>ä½œæ¶æƒ©ç½šæœºåˆ¶</li>
                    <li>å¥–åŠ±åˆ†é…æœºåˆ¶</li>
                    <li>é•¿æœŸæ¿€åŠ±</li>
                </ul>
            </div>
        </div>

        <!-- Configuration Examples -->
        <div class="content">
            <h2>âš™ï¸ é…ç½®ç¤ºä¾‹</h2>
            
            <div class="optimization-section">
                <h3>1. éªŒè¯å™¨æŠ•ç¥¨é…ç½®</h3>
                <pre><code>// æ–‡ä»¶: validator/src/main.rs
// å¯åŠ¨éªŒè¯å™¨æ—¶çš„æŠ•ç¥¨ç›¸å…³é…ç½®
let validator_config = ValidatorConfig {
    // æŠ•ç¥¨è´¦æˆ·
    vote_account: vote_account_keypair.pubkey(),
    // æˆæƒæŠ•ç¥¨è€…
    authorized_voter_keypairs: vec![authorized_voter_keypair],
    // æŠ•ç¥¨ç¨‹åºID
    vote_program_id: solana_vote_program::id(),
    // Towerå­˜å‚¨è·¯å¾„
    tower_storage: Arc::new(FileTowerStorage::new(tower_path)),
    // é¢„æœŸé“¶è¡Œå“ˆå¸Œ
    expected_bank_hash: None,
    // ç­‰å¾…æŠ•ç¥¨ç¡®è®¤
    wait_for_supermajority: Some(wait_for_supermajority_slot),
    ..ValidatorConfig::default()
};</code></pre>
            </div>

            <div class="optimization-section">
                <h3>2. å…±è¯†å‚æ•°é…ç½®</h3>
                <pre><code>// æ–‡ä»¶: runtime/src/genesis_utils.rs  
pub fn create_genesis_config_with_vote_accounts(
    mint_lamports: u64,
    voting_keypairs: &[VotingKeypair],
    stakes: Vec<u64>,
) -> GenesisConfig {
    let mut genesis_config = GenesisConfig {
        accounts: AccountsMap::new(),
        // Proof of Historyé…ç½®
        poh_config: PohConfig {
            target_tick_duration: Duration::from_micros(6_250), // 160 ticks/slot
            target_tick_count: Some(8), // devæ¨¡å¼ä¸‹è¾ƒå°å€¼
            hashes_per_tick: Some(4),
        },
        // è´¹ç”¨é…ç½®  
        fee_rate_governor: FeeRateGovernor::new(5000, 0),
        // ç§Ÿé‡‘é…ç½®
        rent: Rent::default(),
        // epochè°ƒåº¦
        epoch_schedule: EpochSchedule::default(),
        // é€šèƒ€é…ç½®
        inflation: Inflation::default(),
        ..GenesisConfig::default()
    };
    
    // åˆ›å»ºæŠ•ç¥¨è´¦æˆ·
    for (voting_keypair, stake) in voting_keypairs.iter().zip(stakes) {
        let vote_account = Account::new_data(
            stake,
            &VoteState::default(),
            &solana_vote_program::id(),
        ).unwrap();
        
        genesis_config.accounts.insert(
            voting_keypair.vote_keypair.pubkey(),
            vote_account,
        );
    }
    
    genesis_config
}</code></pre>
            </div>

            <div class="optimization-section">
                <h3>3. Toweré…ç½®æ–‡ä»¶</h3>
                <pre><code>// æ–‡ä»¶: core/src/consensus/tower_storage.rs
#[derive(Debug, Serialize, Deserialize)]
pub struct SavedTower {
    pub signature: Signature,
    pub data: SavedTowerVersions,
}

#[derive(Debug, Serialize, Deserialize)]
pub enum SavedTowerVersions {
    V1_14_14(SavedTowerV1_14_14),
    Current(SavedTowerV1_17_14),
}

#[derive(Debug, Serialize, Deserialize)]
pub struct SavedTowerV1_17_14 {
    pub node_pubkey: Pubkey,
    pub threshold_depth: usize,
    pub threshold_size: f64,
    pub vote_state_timestamps: HashMap<Slot, UnixTimestamp>,
    pub last_vote: Vote,
    pub last_vote_tx_blockhash: Hash,
    pub last_vote_bankhash: Hash,
    pub shred_version: u16,
    pub wallclock: u64,
}

// Toweré…ç½®ç¤ºä¾‹JSON
/*
{
  "signature": "4fX2nJ8...",
  "data": {
    "Current": {
      "node_pubkey": "5QqK9zwSwn5h7JdNb...",
      "threshold_depth": 8,
      "threshold_size": 0.67,
      "vote_state_timestamps": {
        "12345": 1647894123,
        "12346": 1647894523
      },
      "last_vote": {
        "slots": [12346, 12347],
        "hash": "8WzQS4bz...",
        "timestamp": 1647894523
      },
      "shred_version": 1,
      "wallclock": 1647894523000000
    }
  }
}
*/</code></pre>
            </div>
        </div>

        <!-- Future Improvements -->
        <div class="content">
            <h2>ğŸ”® æœªæ¥æ”¹è¿›</h2>
            
            <div class="optimization-section">
                <h3>1. æ€§èƒ½ä¼˜åŒ–</h3>
                <ul>
                    <li>æå‡äº¤æ˜“ååé‡</li>
                    <li>é™ä½ç¡®è®¤å»¶è¿Ÿ</li>
                    <li>ä¼˜åŒ–ç½‘ç»œä¼ è¾“</li>
                    <li>æ”¹è¿›å­˜å‚¨æ•ˆç‡</li>
                </ul>
            </div>

            <div class="optimization-section">
                <h3>2. å®‰å…¨å¢å¼º</h3>
                <ul>
                    <li>å¼•å…¥ç¨‹åºåŒ–æƒ©ç½š</li>
                    <li>æ”¹è¿›åˆ†å‰é€‰æ‹©</li>
                    <li>å¢å¼ºæ”»å‡»é˜²æŠ¤</li>
                    <li>ä¼˜åŒ–æŠ•ç¥¨æœºåˆ¶</li>
                </ul>
            </div>

            <div class="optimization-section">
                <h3>3. å»ä¸­å¿ƒåŒ–æå‡</h3>
                <ul>
                    <li>é™ä½éªŒè¯é—¨æ§›</li>
                    <li>ä¼˜åŒ–æƒç›Šåˆ†å¸ƒ</li>
                    <li>æ”¹è¿›æ²»ç†æœºåˆ¶</li>
                    <li>å¢å¼ºç¤¾åŒºå‚ä¸</li>
                </ul>
            </div>
        </div>

        <!-- Footer -->
        <footer class="footer">
            <p>AgaveéªŒè¯å™¨æ–‡æ¡£ä¸­å¿ƒ â€¢ ä¸ºSolanaç”Ÿæ€å¼€å‘å’ŒéªŒè¯å™¨è¿è¥è€Œåˆ›å»º</p>
            <p>ğŸŒªï¸ åŠ©åŠ›æ„å»ºé«˜æ€§èƒ½åŒºå—é“¾ç½‘ç»œï¼Œæ”¯æ’‘Web3æœªæ¥</p>
        </footer>

        <!-- Theme Toggle Button -->
        <button class="theme-toggle" id="themeToggle" aria-label="åˆ‡æ¢æ·±è‰²æ¨¡å¼">
            ğŸŒ“
        </button>
    </div>

    <script>
        // Search functionality
        document.getElementById('searchInput').addEventListener('input', function(e) {
            const searchTerm = e.target.value.toLowerCase();
            const sections = document.querySelectorAll('.content, .pipeline-section, .optimization-section');
            
            sections.forEach(section => {
                const text = section.textContent.toLowerCase();
                if (text.includes(searchTerm) || searchTerm === '') {
                    section.style.display = 'block';
                } else {
                    section.style.display = 'none';
                }
            });
        });

        // Theme Toggle
        const themeToggle = document.getElementById('themeToggle');
        const prefersDarkScheme = window.matchMedia('(prefers-color-scheme: dark)');
        
        function toggleTheme() {
            document.body.classList.toggle('dark-theme');
            localStorage.setItem('theme', document.body.classList.contains('dark-theme') ? 'dark' : 'light');
        }

        // åˆå§‹åŒ–ä¸»é¢˜
        if (localStorage.getItem('theme') === 'dark' || (!localStorage.getItem('theme') && prefersDarkScheme.matches)) {
            document.body.classList.add('dark-theme');
        }

        themeToggle.addEventListener('click', toggleTheme);
        prefersDarkScheme.addListener((e) => {
            if (!localStorage.getItem('theme')) {
                if (e.matches) {
                    document.body.classList.add('dark-theme');
                } else {
                    document.body.classList.remove('dark-theme');
                }
            }
        });

        // Enhanced copy functionality to code blocks with file paths
        document.querySelectorAll('pre code').forEach(block => {
            // Add copy button
            const copyButton = document.createElement('button');
            copyButton.className = 'copy-button';
            copyButton.textContent = 'å¤åˆ¶';
            copyButton.style.cssText = `
                position: absolute;
                top: 8px;
                right: 8px;
                background: var(--primary-purple);
                color: white;
                border: none;
                border-radius: 4px;
                padding: 4px 8px;
                font-size: 12px;
                cursor: pointer;
                opacity: 0;
                transition: opacity 0.3s;
            `;
            
            const pre = block.parentElement;
            pre.style.position = 'relative';
            pre.appendChild(copyButton);
            
            // Show/hide copy button on hover
            pre.addEventListener('mouseenter', () => copyButton.style.opacity = '1');
            pre.addEventListener('mouseleave', () => copyButton.style.opacity = '0');
            
            copyButton.addEventListener('click', function(e) {
                e.stopPropagation();
                navigator.clipboard.writeText(block.textContent).then(() => {
                    copyButton.textContent = 'å·²å¤åˆ¶!';
                    copyButton.style.background = 'var(--success-green)';
                    setTimeout(() => {
                        copyButton.textContent = 'å¤åˆ¶';
                        copyButton.style.background = 'var(--primary-purple)';
                    }, 2000);
                });
            });
        });

        // Highlight file paths in code blocks
        document.querySelectorAll('pre code').forEach(block => {
            let html = block.innerHTML;
            // Highlight file paths (starting with //)
            html = html.replace(/(\/\/ æ–‡ä»¶: [^\n]+)/g, '<span style="color: var(--secondary-orange); font-weight: bold;">$1</span>');
            // Highlight struct/impl keywords
            html = html.replace(/\b(struct|impl|enum|fn|pub|use|mod)\b/g, '<span style="color: var(--accent-teal); font-weight: bold;">$1</span>');
            block.innerHTML = html;
        });

        // Add loading indicator for navigation
        document.querySelectorAll('a').forEach(link => {
            link.addEventListener('click', function(e) {
                if (!this.href.startsWith('#')) {
                    const loading = document.createElement('div');
                    loading.className = 'loading';
                    this.appendChild(loading);
                }
            });
        });

        // Smooth scrolling for anchor links
        document.querySelectorAll('a[href^="#"]').forEach(anchor => {
            anchor.addEventListener('click', function (e) {
                e.preventDefault();
                const target = document.querySelector(this.getAttribute('href'));
                if (target) {
                    target.scrollIntoView({
                        behavior: 'smooth',
                        block: 'start'
                    });
                }
            });
        });
    </script>
</body>
</html> 